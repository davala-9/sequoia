Index: sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextStructureManager.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This file is part of Sequoia, an OWL 2 reasoner that supports the SRIQ subset of OWL 2 DL.\n * Copyright 2017 by Andrew Bate <code@andrewbate.com>.\n *\n * This code is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 3 only,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License version 3 for more details (a copy is\n * included in the LICENSE file that accompanied this code).\n *\n * You should have received a copy of the GNU General Public License\n * version 3 along with this work.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage com.sequoiareasoner.kernel.context\n\nimport com.sequoiareasoner.kernel.clauses._\nimport com.sequoiareasoner.kernel.index.{ArrayBuilders, ImmutableSet, NeighborPredClauseIndex, TotalIRIMultiMap, _}\nimport com.sequoiareasoner.kernel.logging.Logger\nimport com.sequoiareasoner.kernel.owl.iri.IRI\nimport com.sequoiareasoner.kernel.owl.model.{NamedIndividual, OWLClass}\nimport com.sequoiareasoner.kernel.structural.DLOntology\nimport com.sequoiareasoner.kernel.taxonomy.Taxonomy\nimport org.semanticweb.owlapi.model.OWLNamedIndividual\n\nimport scala.collection.mutable\nimport java.util.concurrent.CountDownLatch\nimport java.util.concurrent.atomic.AtomicInteger\nimport java.util.concurrent.LinkedTransferQueue\nimport java.util.concurrent.ForkJoinPool\nimport java.util.concurrent.Callable\n\n/** Class that manages the context structure, including the introducing of new contexts according to a supplied strategy\n  * function, and the termination of the procedure once all contexts have completed saturation. */\n\n /** IMPORTANT INFORMATION: Currently, the Context Structure Manager is hardcoded to, on creation, run only once,\n   * and check all atomic queries of the form A(x) -> B(x), for A(x) an OWLClass in the input ontology\n   * this includes auxiliary classes for nominals.\n   * In the future, we will implement a more fine degree of control of which queries have been checked,\n   * to allow for shorter computations and incremental reasoning. */\n\nfinal class ContextStructureManager(ontology: DLOntology,\n                                    redundancyIndex: => ContextClauseRedundancyIndex,\n                                    enableEqualityReasoning: Boolean,\n                                    equalityOptimization: => EqualityOptimization,\n                                    strategy: ImmutableSet[Predicate] => ImmutableSet[Predicate],\n                                    targetConcepts: Set[Int],\n                                    logger: Logger) {\n\n   if (ontology eq null) throw new NullPointerException\n\n //  require(query.keys.forall( x => IRI(x).isImported || IRI(x).isInternalIndividual || IRI(x).isThing))\n//  require(query.values.flatten.forall( x => IRI(x).isImported || IRI(x).isInternalIndividual || IRI(x).isThing))\n\n\n  /**------------------------- Context Structure fields and methods------------------------ */\n\n\n  /** This map provides, for each set of predicates, a channel to the context that has that set as its core */\n  private[this] val contexts = new mutable.AnyRefMap[ImmutableSet[Predicate], ContextRunnable]\n  private[this] val contextExecutor = new ForkJoinPool();\n  private[this] val executor2 = new ForkJoinPool();\n  def messageContext(context: ContextRunnable, message: InterContextMessage): Unit = {\n    executor2.execute(() => context.reSaturateUponMessage(message))\n  }\n\n  /** This map provides, for each nominal context O(x), the set of (other) contexts that mention o */\n  private[this] val constantIndex = new mutable.AnyRefMap[Constant,collection.mutable.Set[ImmutableSet[Predicate]]]\n  /** Add a context to the index mapping each constant to the list of contexts that mention it */\n  def addToConstantIndex(individual: Constant, core: ImmutableSet[Predicate]) = synchronized {\n    constantIndex.getOrElseUpdate(individual, collection.mutable.Set[ImmutableSet[Predicate]]()) += core\n    Unit\n  }\n\n  /** `superConcepts(a)` collects subsumption relations between  all the (direct and non-direct) super concepts of `a`. */\n  private[this] val provedAtomicQueries = new TotalIRIMultiMap[IRI](ArrayBuilders.iriArrayBuilder)\n\n  /** This records whether a contradiction clause has been derived.  */\n  //TODO: stop reasoner whenever inconsistency has been derived\n  var contradictionDerived = false\n  def flagOntologyAsInconsistent(): Unit = synchronized { contradictionDerived = true }\n  def contradictionHasBeenDerived: Boolean = synchronized { contradictionDerived }\n\n\n   /**-------------------------- Flow Control --------------------------*/\n\n\n  private[this] var beginTime: Long = 0L\n  private[this] var totalTime: Long = 0L\n  private[this] var hornPhaseActive: Boolean = true\n  /** Counts the number of contexts that are currently active */\n  /** THIS IS A HACK: this is automatically initialised with the number of classes to be classified */\n  val activeCount = new AtomicInteger(targetConcepts.size) // !!! TODO : make private again\n  /** Latch used for awaiting for and terminating the process that constructs the saturated context structure */\n  //TODO: Make latch private again;\n  val latch = new CountDownLatch(1)\n  val secondLatch = new CountDownLatch(1)\n  def activeLatch = {\n    if (hornPhaseActive) latch; else secondLatch\n  }\n  protected[context] def contextRoundStarted(): Unit =  activeCount.incrementAndGet\n  protected[context] def contextRoundFinished(): Unit = {\n    val count = activeCount.decrementAndGet\n    println(\"decrementing ac\" + count)\n    println(\"?\")\n    if (count == 0) println(\"!!\")\n    if (count < 0) {\n      println(\"ruhroh\")\n      throw new IllegalStateException\n    }\n    if (count == 0) {\n      println(\"!!!\")\n      totalTime = System.currentTimeMillis - beginTime\n      println(\"!!!!\")\n      logger.info(s\"Saturation completed in $totalTime.\")\n      println(\"!!!!!\")\n      activeLatch.countDown()\n      println(\"!!x!!\")\n      println(secondLatch.getCount(), activeLatch.getCount())\n    }\n  }\n  /** Wait until the Context structure is saturated */\n  def waitForSaturation: Unit = {\n // HORN OPTIMISATION  /** Horn phase */\n    latch.await()\n//    /** Non-horn phase */\n    println(\"surely we get here\")\n    synchronized { hornPhaseActive = false }\n    println(\"synced\")\n    activeCount.set(contexts.values.size)\n    for (context <- getAllContexts) {\n      context.reSaturateUponMessage(StartNonHornPhase())\n    }\n    secondLatch.await()\n    println(\"past the 2nd latch\")\n }\n  /** Stop ASAP the construction of the context structure */\n  def interrupt(): Unit = synchronized {\n    if (ontology.havocTriggered) {\n      while (activeLatch.getCount > 0) activeLatch.countDown()\n    }\n  }\n\n\n\n   // Uncommenting for the Kaminsky optimisation\n   private[this] val certainFacts: mutable.Map[Int,mutable.Set[Int]] = ontology.ensureTrivialFactsAddedAndGetABox\n   def addCertainGroundFact(predicate: Int, nominal: Int) = synchronized {\n     certainFacts.getOrElseUpdate(nominal, collection.mutable.Set[Int]()) += predicate\n   }\n//   private[this] val derivedNewCertainGroundFacts = collection.immutable.HashSet[Predicate]()\n   def getCertainFacts(nominal: Int) = synchronized {\n     certainFacts(nominal)\n   }\n//   def getCertainGroundFacts(ordering: ContextLiteralOrdering): Seq[ContextClause] = synchronized {\n//     (for ( (k,v) <- certainFacts.iterator; pred <- v) yield ContextClause(Array[Predicate](),\n//       Array[Literal](Concept(IRI(pred),Term(IRI.importedIriUid2IriNameString(k)))(ontology)))(ordering)).toSeq\n//   }\n\n  /** -------------------------- Operations on the context structure -------------------*/\n\n\n  private[this] def buildContext(queryConcepts: Set[Int],\n                                 core: ImmutableSet[Predicate],\n                                 rootContext: Boolean,\n                                 workedOffClauseIndex: ContextClauseIndex,\n                                 ordering: ContextLiteralOrdering,\n                                 hornPhaseActive: Boolean): Callable[ContextRunnable] = () => {\n   // Ignore this parameter for the moment. Require(ordering.verifyQuery(queryConcepts))\n    val state = if (core.toSeq.head.iri.isInternalIndividual) {\n      new NominalContextState(queryConcepts, core, rootContext, workedOffClauseIndex,\n        new NeighborPredClauseIndex, equalityOptimization, redundancyIndex, hornPhaseActive,ordering,ontology, contextStructureManager = this)\n    } else {\n      new ContextState(queryConcepts, core, rootContext, workedOffClauseIndex, new NeighborPredClauseIndex,\n        equalityOptimization, redundancyIndex, hornPhaseActive, ordering, ontology, contextStructureManager = this)\n    }\n    new ContextRunnable(state, ontology, enableEqualityReasoning, ordering, contextStructureManager = this)\n  }\n\n  def getAllContexts: Iterable[ContextRunnable] = synchronized { contexts.values }\n\n  /** Given a conjunction of known predicates, this method identifies the successor given by the _strategy_ of this\n    * context structure, and then retrieves it or creates it; in the latter case, it initialises the first round */\n  def getSuccessor(K1: ImmutableSet[Predicate]): ContextRunnable = synchronized {\n    val core: ImmutableSet[Predicate] = strategy(K1)\n    if (core.isEmpty) logger.warn(s\"WARNING: trivial context is active! (K1 = $K1)\")\n    contexts.getOrElseUpdate(core, {\n      /** If we create the context, then it is not a root context so the Index is a standard ContextClauseIndex */\n      val contextIndex = new ContextClauseIndex\n      /** Since this is not a root context, the query is empty */\n      val ordering = ContextLiteralOrdering(Set[Int]())\n      val createNewContext: Callable[ContextRunnable] = buildContext(Set[Int](), core, rootContext = false, contextIndex, ordering, hornPhaseActive)\n      println(\"Starting new context\", activeCount.get())\n      contextRoundStarted()\n      println(\"Started\", activeCount.get())\n      val context: ContextRunnable = contextExecutor.submit(createNewContext).get\n      executor2.execute(context.saturateAndPush())\n      context\n    })\n  }\n  /** Given a constant, retrieve or create the nominal context corresponding to that constant. If it is created,\n    * the initialisation round is started.*/\n  protected[context] def getNominalContext(individual: Constant) : ContextRunnable = synchronized {\n    implicit val theOntology = ontology\n    val core: ImmutableSet[Predicate] = ImmutableSet(Concept(IRI.nominalConcept(individual.toString),CentralVariable))\n    contexts.getOrElseUpdate(core, {\n      // System.out.println(\"NOMINAL NODE CREATED for core \" + core + \" !!\")\n      /** Since each nominal context is a root context, we introduce a root context index */\n      val contextIndex = new RootContextClauseIndex(provedAtomicQueries.addKey(IRI.nominalConcept(individual.toString)))\n      /** Since nominal contexts have no query, the query is empty */\n      val ordering = ContextLiteralOrdering(Set[Int]())\n      val createNewContext: Callable[ContextRunnable] = buildContext(Set[Int](), core, rootContext = true, contextIndex, ordering, hornPhaseActive)\n      contextRoundStarted()\n      val context: ContextRunnable = contextExecutor.submit(createNewContext).get\n      executor2.execute(context.saturateAndPush())\n      context\n    })\n  }\n  protected[context] def getContextsWithNominal(individual: Constant): Iterable[ImmutableSet[Predicate]] = synchronized {\n    constantIndex(individual)\n  }\n\n\n  /** ------------------------------ Output Methods -------------------------------------- */\n\n  def getClassesTaxonomy: Taxonomy[OWLClass] = {\n    val classHierarchy = new TotalIRIMultiMap[IRI](ArrayBuilders.iriArrayBuilder)\n    provedAtomicQueries.foreachKeys(key => {\n//      println(\"provedAtomicQuery key: \")\n//      println(key)\n//      println(\"Values\")\n//      provedAtomicQueries(key).foreach( iri => println(iri))\n//      println(\"Is empty?: \" + provedAtomicQueries(key).isEmpty)\n      if (key.isImported) provedAtomicQueries(key).foreach(value => classHierarchy.addBinding(key, value))\n    })\n    Taxonomy[OWLClass](classHierarchy, Some(IRI.owlNothing), Some(IRI.owlThing))\n  }\n\n  def getIndividualsTaxonomy: Taxonomy[NamedIndividual] = {\n    val individualHierarchy = new TotalIRIMultiMap[IRI](ArrayBuilders.iriArrayBuilder)\n    provedAtomicQueries.foreachKeys(key => {\n      if (key.isInternalIndividual) provedAtomicQueries(key).foreach(value =>\n        individualHierarchy.addBinding(IRI(IRI.nominalConceptUid2NominalIriStringName(key.uid)), value))\n    })\n    Taxonomy[NamedIndividual](individualHierarchy)\n  }\n\n  /** -------------------- Saturation of the Context Structure (ON CREATION) ------------------- */\n\n\n  synchronized {\n    beginTime = System.currentTimeMillis\n    /** This process creates a context for each relevant concept, and initialises such concepts) */\n    implicit val theOntology = ontology\n    for (concept <- targetConcepts) {\n      val core: ImmutableSet[Predicate] = ImmutableSet(Concept(IRI(concept),CentralVariable))\n      contexts.put(core, {\n        /** Creates the context index, which is a special case since these contexts are query contexts. */\n        val contextIndex = new RootContextClauseIndex(provedAtomicQueries.addKey(IRI(concept)))\n        val newContext: Callable[ContextRunnable] = buildContext(queryConcepts = Set.empty[Int], core, rootContext = true, contextIndex,\n          ContextLiteralOrdering(), hornPhaseActive)\n        println(\"building context\")\n        val context = contextExecutor.submit(newContext).get\n        println(\"built now saturate\")\n        executor2.execute(context.saturateAndPush())\n        println(\"saturated\")\n        context\n      })\n    }\n  }\n   waitForSaturation\n   println(\"gothere\")\n}\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextStructureManager.scala b/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextStructureManager.scala
--- a/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextStructureManager.scala	
+++ b/sequoia/reasoner-kernel/src/main/scala/com/sequoiareasoner/kernel/context/ContextStructureManager.scala	
@@ -35,6 +35,7 @@
 import java.util.concurrent.LinkedTransferQueue
 import java.util.concurrent.ForkJoinPool
 import java.util.concurrent.Callable
+import java.util.concurrent.Executors
 
 /** Class that manages the context structure, including the introducing of new contexts according to a supplied strategy
   * function, and the termination of the procedure once all contexts have completed saturation. */
